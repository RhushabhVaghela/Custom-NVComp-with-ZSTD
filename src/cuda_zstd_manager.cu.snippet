    Status init_predefined_tables(
        sequence::SequenceContext* seq_ctx,
        cudaStream_t stream
    ) {
        // Helper lambda to init one table
        auto init_table = [&](fse::TableType type, void** d_table_ptr, u8** d_decode_ptr) -> Status {
            u32 max_symbol, table_log;
            const u16* norm = fse::get_predefined_norm(type, &max_symbol, &table_log);
            if (!norm) return Status::ERROR_INVALID_PARAMETER;

            u32 table_size = 1u << table_log;

            // 1. Build Encode Table (for newStateBase & nbBits)
            fse::FSEEncodeTable h_enc_table;
            Status status = fse::FSE_buildCTable_Host(norm, max_symbol, table_log, &h_enc_table);
            if (status != Status::SUCCESS) return status;

            // Copy symbol table to device
            fse::FSEEncodeTable::FSEEncodeSymbol* d_sym_table;
            u32 sym_size = (max_symbol + 1) * sizeof(fse::FSEEncodeTable::FSEEncodeSymbol);
            CUDA_CHECK(cudaMalloc(&d_sym_table, sym_size));
            CUDA_CHECK(cudaMemcpyAsync(d_sym_table, h_enc_table.d_symbol_table, sym_size, cudaMemcpyHostToDevice, stream));
            
            // Update struct with device pointer
            h_enc_table.d_symbol_table = d_sym_table;
            delete[] h_enc_table.d_symbol_table; // Free host buffer allocated by buildCTable

            // Copy struct to device
            fse::FSEEncodeTable* d_enc_table;
            CUDA_CHECK(cudaMalloc(&d_enc_table, sizeof(fse::FSEEncodeTable)));
            CUDA_CHECK(cudaMemcpyAsync(d_enc_table, &h_enc_table, sizeof(fse::FSEEncodeTable), cudaMemcpyHostToDevice, stream));
            
            *d_table_ptr = d_enc_table;

            // 2. Build Decode Table (for state->symbol mapping)
            fse::FSEDecodeTable h_dec_table;
            status = fse::FSE_buildDTable_Host(norm, max_symbol, table_size, h_dec_table);
            if (status != Status::SUCCESS) return status;

            // We only need the symbol mapping for the kernel (d_ll_decode)
            u8* d_decode;
            CUDA_CHECK(cudaMalloc(&d_decode, table_size * sizeof(u8)));
            CUDA_CHECK(cudaMemcpyAsync(d_decode, h_dec_table.symbol, table_size * sizeof(u8), cudaMemcpyHostToDevice, stream));
            
            *d_decode_ptr = d_decode;

            // Cleanup host tables
            delete[] h_dec_table.newState;
            delete[] h_dec_table.symbol;
            delete[] h_dec_table.nbBits;

            return Status::SUCCESS;
        };

        Status s;
        s = init_table(fse::TableType::LITERALS, &seq_ctx->d_ll_table, &seq_ctx->d_ll_decode);
        if (s != Status::SUCCESS) return s;

        s = init_table(fse::TableType::MATCH_LENGTHS, &seq_ctx->d_ml_table, &seq_ctx->d_ml_decode);
        if (s != Status::SUCCESS) return s;

        s = init_table(fse::TableType::OFFSETS, &seq_ctx->d_of_table, &seq_ctx->d_of_decode);
        if (s != Status::SUCCESS) return s;

        return Status::SUCCESS;
    }
