// ============================================================================
// cuda_zstd_huffman.cu - Complete Huffman Encoding/Decoding Implementation
//
// NOTE: This file is now fully parallelized.
// - 'huffman_encode_kernel' is a parallel 2-pass scan + write.
// - 'huffman_decode_sequential_kernel' is now a true parallel chunked decoder
//   (using a setup kernel to find chunk starts).
//
// (NEW) NOTE: Refactored to use cuda_zstd_utils for parallel_scan.
// ============================================================================

#include "cuda_zstd_huffman.h"
#include "cuda_zstd_internal.h"
#include "cuda_zstd_types.h"
#include "cuda_zstd_utils.h" // <-- 1. ADDED INCLUDE

#include <algorithm>
#include <cstring>
#include <functional>
#include <queue>
#include <vector>

// Note: A production implementation would use CUB for these scans.
// We implement them manually to be self-contained.

namespace cuda_zstd {
namespace huffman {

// ============================================================================
// Huffman Constants
// ============================================================================

constexpr u32 HUFFMAN_ENCODE_THREADS = 256;
// constexpr u32 HUFFMAN_DECODE_THREADS_PER_CHUNK = 1; // Decode is sequential
// per chunk constexpr u32 HUFFMAN_DECODE_SYMBOLS_PER_CHUNK = 4096; // Symbols
// per chunk

// ============================================================================
// Huffman Structures (from .h file, repeated for context)
// ============================================================================

struct HuffmanEncodeTable {
  HuffmanCode *codes;
  u32 num_symbols;
  u32 max_code_length;
  u8 *h_code_lengths;
};

struct HuffmanDecodeTable {
  u16 *d_fast_lookup;
  u32 *d_decode_info;
  u32 max_length;
};

// ============================================================================
// Parallel Scan Kernels (for Encode)
// (REMOVED) - This entire section is now gone and moved to cuda_zstd_utils.cu
// ============================================================================
// Device Helper Functions
// ============================================================================

__device__ inline u32 reverse_bits_device(u32 val, u32 bits) {
  return __brev(val) >> (32 - bits);
}

__device__ void atomicOrByte(byte_t *address, byte_t val) {
  unsigned int *base_addr = (unsigned int *)((size_t)address & ~3);
  unsigned int offset = (size_t)address & 3;
  unsigned int shift = offset * 8;

  unsigned int old = *base_addr;
  unsigned int assumed;
  do {
    assumed = old;
    unsigned int new_val = assumed | ((unsigned int)val << shift);
    old = atomicCAS(base_addr, assumed, new_val);
  } while (assumed != old);
}

// ============================================================================
// Kernels
// ============================================================================
// Frequency Analysis Kernel
// ============================================================================

__global__ void analyze_frequencies_kernel(const byte_t *input, u32 input_size,
                                           u32 *global_frequencies) {
  __shared__ u32 local_freq[MAX_HUFFMAN_SYMBOLS];

  int tid = threadIdx.x;
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  int stride = blockDim.x * gridDim.x;

  if (tid < MAX_HUFFMAN_SYMBOLS) {
    local_freq[tid] = 0;
  }
  __syncthreads();

  for (int i = idx; i < input_size; i += stride) {
    u8 symbol = input[i];
    atomicAdd(&local_freq[symbol], 1);
  }
  __syncthreads();

  if (tid < MAX_HUFFMAN_SYMBOLS) {
    if (local_freq[tid] > 0) {
      atomicAdd(&global_frequencies[tid], local_freq[tid]);
    }
  }
}

__global__ void collect_chunk_offsets_kernel(const u32 *d_bit_offsets,
                                             u32 input_size,
                                             u32 *d_chunk_offsets,
                                             u32 chunk_size_symbols,
                                             u32 num_chunks) {
  u32 chunk_idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (chunk_idx >= num_chunks)
    return;

  u32 symbol_idx = chunk_idx * chunk_size_symbols;
  if (symbol_idx < input_size) {
    d_chunk_offsets[chunk_idx] = d_bit_offsets[symbol_idx];
  }
}

// ============================================================================
// Host Huffman Tree/Table Builder
// ============================================================================

class HuffmanTreeBuilder {
  struct NodeComparator {
    const HuffmanNode *nodes;
    NodeComparator(const HuffmanNode *n) : nodes(n) {}
    bool operator()(int a, int b) const {
      return nodes[a].frequency > nodes[b].frequency;
    }
  };

public:
  static void build_tree(const u32 *frequencies, u32 num_symbols,
                         HuffmanNode *nodes, u32 &num_nodes, i32 &root_idx) {
    NodeComparator comp(nodes);
    std::priority_queue<int, std::vector<int>, NodeComparator> pq(comp);
    num_nodes = 0;
    for (u32 i = 0; i < num_symbols; ++i) {
      if (frequencies[i] > 0) {
        nodes[num_nodes] = {static_cast<u16>(i), frequencies[i],
                            HUFFMAN_NULL_IDX, HUFFMAN_NULL_IDX,
                            HUFFMAN_NULL_IDX};
        pq.push(num_nodes);
        num_nodes++;
      }
    }
    if (num_nodes == 0) {
      root_idx = HUFFMAN_NULL_IDX;
      return;
    }
    if (num_nodes == 1) {
      i32 leaf = pq.top();
      nodes[num_nodes] = {0, nodes[leaf].frequency, static_cast<u16>(leaf),
                          HUFFMAN_NULL_IDX, HUFFMAN_NULL_IDX};
      nodes[leaf].parent = static_cast<u16>(num_nodes);
      root_idx = num_nodes;
      num_nodes++;
      return;
    }
    while (pq.size() > 1) {
      int left = pq.top();
      pq.pop();
      int right = pq.top();
      pq.pop();
      int parent = num_nodes;
      nodes[parent] = {0, nodes[left].frequency + nodes[right].frequency,
                       static_cast<u16>(left), static_cast<u16>(right),
                       HUFFMAN_NULL_IDX};
      nodes[left].parent = static_cast<u16>(parent);
      nodes[right].parent = static_cast<u16>(parent);
      pq.push(parent);
      num_nodes++;
    }
    root_idx = pq.top();
  }
};

__host__ Status serialize_huffman_table(const u8 *h_code_lengths,
                                        byte_t *h_output, u32 *header_size) {
  h_output[0] = MAX_HUFFMAN_BITS;
  u32 offset = 1;
  memcpy(h_output + offset, h_code_lengths, MAX_HUFFMAN_SYMBOLS);
  offset += MAX_HUFFMAN_SYMBOLS;

  *header_size = offset;
  return Status::SUCCESS;
}

__host__ Status deserialize_huffman_table(const byte_t *h_input, u32 input_size,
                                          u8 *h_code_lengths,
                                          u32 *header_size) {
  if (input_size < 1 + MAX_HUFFMAN_SYMBOLS) {
    return Status::ERROR_CORRUPT_DATA;
  }
  u32 max_bits = h_input[0];
  if (max_bits > MAX_HUFFMAN_BITS) {
    return Status::ERROR_CORRUPT_DATA;
  }

  memcpy(h_code_lengths, h_input + 1, MAX_HUFFMAN_SYMBOLS);
  *header_size = 1 + MAX_HUFFMAN_SYMBOLS;

  return Status::SUCCESS;
}

// ============================================================================
// RFC 8878 Huffman Weight Decoding (Standard Zstandard Format)
// ============================================================================

/**
 * @brief Decode Huffman weights from direct 4-bit representation.
 * RFC 8878 Section 4.2.1.1: When headerByte >= 128, weights are stored
 * as 4-bit nibbles (2 weights per byte).
 *
 * @param h_input Input buffer starting at first weight byte
 * @param header_byte The header byte value (determines number of symbols)
 * @param h_weights Output: decoded weights (0-11 range)
 * @param num_symbols Output: number of decoded symbols
 * @return Status::SUCCESS on success
 */
__host__ Status decode_huffman_weights_direct(const byte_t *h_input,
                                              u32 header_byte, u8 *h_weights,
                                              u32 *num_symbols) {
  if (header_byte < 128) {
    return Status::ERROR_CORRUPT_DATA; // Not direct format
  }

  *num_symbols =
      header_byte - 127; // RFC 8878: Number_of_Symbols = headerByte - 127

  // Read 4-bit weights, 2 per byte
  // RFC 8878: Weight[0] = (Byte[0] >> 4), Weight[1] = (Byte[0] & 0xf), etc.
  // Note: num_bytes = (*num_symbols + 1) / 2 is computed implicitly below

  for (u32 i = 0; i < *num_symbols; i++) {
    u32 byte_idx = i / 2;
    if (i % 2 == 0) {
      h_weights[i] = (h_input[byte_idx] >> 4) & 0x0F;
    } else {
      h_weights[i] = h_input[byte_idx] & 0x0F;
    }
  }

  return Status::SUCCESS;
}

/**
 * @brief RFC 8878 FSE Header Reader (Forward Reading)
 * 
 * Reads FSE header values from the bitstream. The header values are encoded
 * using a variable-length format where each value's bit count depends on the
 * remaining table slots.
 */
struct FSEHeaderReader {
  const byte_t *data;
  u32 size_bytes;
  u32 bit_pos;  // Current reading position in bits (forward)
  u32 bits_available;
  u64 accumulator;

  __host__ FSEHeaderReader(const byte_t *d, u32 sz) 
      : data(d), size_bytes(sz), bit_pos(0), bits_available(0), accumulator(0) {}

  // Ensure we have at least n bits in the accumulator
  __host__ void fill(u32 n) {
    while (bits_available < n && bit_pos < size_bytes * 8) {
      accumulator |= ((u64)data[bit_pos / 8] >> (bit_pos % 8)) << bits_available;
      bits_available += 8;
      bit_pos += 8;
    }
    // Clamp to available bits
    if (bits_available > size_bytes * 8 - (bit_pos - bits_available)) {
      bits_available = size_bytes * 8 - (bit_pos - bits_available);
    }
  }

  // Read n bits from the stream
  __host__ u32 read(u32 n) {
    fill(n);
    u32 result = (u32)(accumulator & ((1ULL << n) - 1));
    accumulator >>= n;
    bits_available -= n;
    return result;
  }
};

/**
 * @brief Decode Huffman weights from FSE-compressed format.
 * RFC 8878 Section 4.2.1.2: When headerByte < 128, weights are FSE-encoded.
 * Uses two interleaved FSE states sharing one distribution table.
 *
 * @param h_input Input buffer starting at FSE table
 * @param compressed_size Size of compressed weights (= headerByte)
 * @param h_weights Output: decoded weights (0-11 range)
 * @param num_symbols Output: number of decoded symbols
 * @return Status::SUCCESS on success
 */
__host__ Status decode_huffman_weights_fse(const byte_t *h_input,
                                           u32 compressed_size, u8 *h_weights,
                                           u32 *num_symbols) {
  // RFC 8878 Section 4.2.1.2: FSE Compression of Huffman Weights
  // - Two interleaved FSE states sharing one distribution table
  // - Max accuracy log is 6 for weight encoding

  u32 accuracy_log = 6;
  constexpr u32 MAX_HUF_ALPHABET = 12; // weights 0-11
  constexpr u32 MAX_TABLE_SIZE = 64;   // 2^6

  u32 table_size = 1 << accuracy_log;
  i16 norm_counts[MAX_HUF_ALPHABET] = {0};

  // Create forward-reading header parser
  FSEHeaderReader reader(h_input, compressed_size);

  i32 remaining = table_size;
  u32 symbol = 0;

  while (remaining > 0 && symbol < MAX_HUF_ALPHABET) {
    // Calculate number of bits for this value
    // nbBits = floor(log2(remaining + 1)) + 1
    u32 nbBits = 0;
    u32 temp = remaining + 1;
    while (temp > 0) {
      nbBits++;
      temp >>= 1;
    }

    // Calculate threshold
    u32 threshold = (1u << nbBits) - 1 - (remaining + 1);

    // Read (nbBits - 1) bits
    u32 v = reader.read(nbBits - 1);
    
    i16 count;
    if (v < threshold) {
      // Small value: count = v - 1
      count = (i16)v - 1;
    } else {
      // Large value: read 1 more bit
      u32 extra = reader.read(1);
      v = (v << 1) | extra;
      count = (i16)(v - 1 - threshold);
    }

    norm_counts[symbol++] = count;

    // Update remaining based on count
    if (count == -1) {
      // count=-1 means probability 0, consumes 2 slots
      remaining -= 2;
    } else {
      // count >= 0 means probability = count + 1
      remaining -= (count + 1);
    }
  }

  u32 num_fse_symbols = symbol;

  // DEBUG: Verify normalization parsing
  fprintf(stderr, "[HUF_FSE] Parsed %u symbols, remaining=%d, expected=0\n",
          num_fse_symbols, remaining);
  fprintf(stderr, "[HUF_FSE] NormCounts: ");
  for (u32 i = 0; i < num_fse_symbols && i < 12; i++) {
    fprintf(stderr, "%d ", (int)norm_counts[i]);
  }
  fprintf(stderr, "\n");

  if (remaining != 0) {
    fprintf(
        stderr,
        "[ERROR] FSE normalization sum mismatch: remaining=%d (should be 0)\n",
        remaining);
    return Status::ERROR_CORRUPT_DATA;
  }

  // Build FSE decode table
  u8 table_symbol[MAX_TABLE_SIZE] = {0};
  u32 step = (table_size >> 1) + (table_size >> 3) + 3;
  u32 mask = table_size - 1;
  u32 pos = 0;

  // First pass: spread symbols with positive counts
  for (u32 s = 0; s < num_fse_symbols; s++) {
    if (norm_counts[s] > 0) {
      for (i32 i = 0; i < norm_counts[s]; i++) {
        table_symbol[pos] = (u8)s;
        pos = (pos + step) & mask;
      }
    }
  }

  // Second pass: place -1 symbols (low probability) at the end
  u32 high_threshold = table_size - 1;
  for (u32 s = 0; s < num_fse_symbols; s++) {
    if (norm_counts[s] == -1) {
      table_symbol[high_threshold--] = (u8)s;
    }
  }

  // Build the decoder table
  u8 fse_symbol[MAX_TABLE_SIZE];
  u8 fse_nbits[MAX_TABLE_SIZE];
  u16 fse_newstate[MAX_TABLE_SIZE];
  u32 symbol_next_idx[MAX_HUF_ALPHABET] = {0};

  for (u32 i = 0; i < table_size; i++) {
    u32 s = table_symbol[i];
    fse_symbol[i] = (u8)s;
    i16 count = norm_counts[s];

    if (count == -1) {
      // Probability -1 symbol: full state reset, read accuracy_log bits
      fse_nbits[i] = (u8)accuracy_log;
      fse_newstate[i] = 0;
    } else {
      // Get state index for this symbol
      u32 state_idx = symbol_next_idx[s]++;

      // Calculate nbBits and baseline per RFC 8878
      u32 n_states = (u32)count + 1; // probability = count + 1
      u32 next_pow2 = 1;
      while (next_pow2 < n_states) {
        next_pow2 <<= 1;
      }
      u32 high_bit = 0;
      u32 tmp = next_pow2;
      while (tmp >>= 1) high_bit++;

      u32 extra_states = next_pow2 - n_states;
      u32 nb_bits = accuracy_log - high_bit;
      u32 baseline = (state_idx + extra_states) << nb_bits;

      fse_nbits[i] = (u8)nb_bits;
      fse_newstate[i] = (u16)(baseline & (table_size - 1));
    }
  }

  // Find start of FSE bitstream (after header)
  u32 header_bits_consumed = reader.bit_pos;
  u32 bitstream_start = (header_bits_consumed + 7) / 8;
  if (bitstream_start >= compressed_size)
    return Status::ERROR_CORRUPT_DATA;

  const byte_t *bitstream = h_input + bitstream_start;
  u32 bitstream_size = compressed_size - bitstream_start;

  // Find the end of the bitstream (scan for sentinel)
  i32 bit_pos = (i32)bitstream_size * 8;
  while (bit_pos > 0) {
    u32 byte_idx = (bit_pos - 1) / 8;
    u32 bit_idx = (bit_pos - 1) % 8;
    if (byte_idx < bitstream_size && (bitstream[byte_idx] & (1 << bit_idx))) {
      break;
    }
    bit_pos--;
  }

  if (bit_pos < (i32)(2 * accuracy_log)) {
    fprintf(stderr, "[ERROR] Not enough bits: bit_pos=%d, need=%u\n", bit_pos,
            2 * accuracy_log);
    return Status::ERROR_CORRUPT_DATA;
  }

  // Load bit container for FSE decoding
  u64 bit_container = 0;
  u32 bits_consumed = 0;

  // Load up to 8 bytes from end as little-endian
  u32 load_size = (bitstream_size > 8) ? 8 : bitstream_size;
  for (u32 i = 0; i < load_size; i++) {
    bit_container |= ((u64)bitstream[bitstream_size - load_size + i])
                     << (i * 8);
  }

  // Find sentinel bit position
  u8 last_byte = bitstream[bitstream_size - 1];
  u32 sentinel_bit = 0;
  for (u32 b = 7; b > 0; b--) {
    if (last_byte & (1 << b)) {
      sentinel_bit = b;
      break;
    }
  }
  if (last_byte == 1)
    sentinel_bit = 0;

  bits_consumed = (8 - sentinel_bit) + (8 - load_size) * 8;
  u32 byte_ptr = bitstream_size - load_size;

  auto read_fse_bits = [&](u32 nbits) -> u32 {
    u32 start = 64 - bits_consumed - nbits;
    u32 result = (u32)((bit_container >> start) & ((1U << nbits) - 1));
    bits_consumed += nbits;

    // Refill if needed
    if (bits_consumed > 56 && byte_ptr > 0) {
      u32 refill = (byte_ptr > 8) ? 8 : byte_ptr;
      u64 new_container = 0;
      for (u32 i = 0; i < refill; i++) {
        new_container |= ((u64)bitstream[byte_ptr - refill + i]) << (i * 8);
      }
      bit_container = (bit_container << (refill * 8)) | new_container;
      bits_consumed = (bits_consumed > refill * 8) ? (bits_consumed - refill * 8) : 0;
      byte_ptr -= refill;
    }
    return result;
  };

  u32 state1 = read_fse_bits(accuracy_log);
  u32 state2 = read_fse_bits(accuracy_log);

  u32 out_idx = 0;
  constexpr u32 MAX_WEIGHTS = 255;

  while (out_idx < MAX_WEIGHTS) {
    // State 1 decode
    if (state1 >= table_size) {
      return Status::ERROR_CORRUPT_DATA;
    }
    u32 idx1 = state1;
    u8 symbol1 = fse_symbol[idx1];
    u32 nb1 = fse_nbits[idx1];

    if (bits_consumed + nb1 > 64) {
      h_weights[out_idx++] = symbol1;
      break;
    }

    state1 = fse_newstate[idx1] + read_fse_bits(nb1);
    h_weights[out_idx++] = symbol1;
    if (bits_consumed >= 64 || out_idx >= MAX_WEIGHTS)
      break;

    // State 2 decode
    if (state2 >= table_size) {
      return Status::ERROR_CORRUPT_DATA;
    }
    u32 idx2 = state2;
    u8 symbol2 = fse_symbol[idx2];
    u32 nb2 = fse_nbits[idx2];

    if (bits_consumed + nb2 > 64) {
      h_weights[out_idx++] = symbol2;
      break;
    }

    state2 = fse_newstate[idx2] + read_fse_bits(nb2);
    h_weights[out_idx++] = symbol2;

    if (bits_consumed >= 64)
      break;
  }

  *num_symbols = out_idx;
  return Status::SUCCESS;
}
